// Code generated by mockery v2.53.4. DO NOT EDIT.

package mocks

import (
	context "context"
	domain "write_base/internal/domain"

	mock "github.com/stretchr/testify/mock"

	time "time"
)

// MockIUserRepository is an autogenerated mock type for the IUserRepository type
type MockIUserRepository struct {
	mock.Mock
}

type MockIUserRepository_Expecter struct {
	mock *mock.Mock
}

func (_m *MockIUserRepository) EXPECT() *MockIUserRepository_Expecter {
	return &MockIUserRepository_Expecter{mock: &_m.Mock}
}

// CreateUser provides a mock function with given fields: ctx, user
func (_m *MockIUserRepository) CreateUser(ctx context.Context, user *domain.User) error {
	ret := _m.Called(ctx, user)

	if len(ret) == 0 {
		panic("no return value specified for CreateUser")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *domain.User) error); ok {
		r0 = rf(ctx, user)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockIUserRepository_CreateUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateUser'
type MockIUserRepository_CreateUser_Call struct {
	*mock.Call
}

// CreateUser is a helper method to define mock.On call
//   - ctx context.Context
//   - user *domain.User
func (_e *MockIUserRepository_Expecter) CreateUser(ctx interface{}, user interface{}) *MockIUserRepository_CreateUser_Call {
	return &MockIUserRepository_CreateUser_Call{Call: _e.mock.On("CreateUser", ctx, user)}
}

func (_c *MockIUserRepository_CreateUser_Call) Run(run func(ctx context.Context, user *domain.User)) *MockIUserRepository_CreateUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*domain.User))
	})
	return _c
}

func (_c *MockIUserRepository_CreateUser_Call) Return(_a0 error) *MockIUserRepository_CreateUser_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockIUserRepository_CreateUser_Call) RunAndReturn(run func(context.Context, *domain.User) error) *MockIUserRepository_CreateUser_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteExpiredTokens provides a mock function with no fields
func (_m *MockIUserRepository) DeleteExpiredTokens() error {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for DeleteExpiredTokens")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockIUserRepository_DeleteExpiredTokens_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteExpiredTokens'
type MockIUserRepository_DeleteExpiredTokens_Call struct {
	*mock.Call
}

// DeleteExpiredTokens is a helper method to define mock.On call
func (_e *MockIUserRepository_Expecter) DeleteExpiredTokens() *MockIUserRepository_DeleteExpiredTokens_Call {
	return &MockIUserRepository_DeleteExpiredTokens_Call{Call: _e.mock.On("DeleteExpiredTokens")}
}

func (_c *MockIUserRepository_DeleteExpiredTokens_Call) Run(run func()) *MockIUserRepository_DeleteExpiredTokens_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockIUserRepository_DeleteExpiredTokens_Call) Return(_a0 error) *MockIUserRepository_DeleteExpiredTokens_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockIUserRepository_DeleteExpiredTokens_Call) RunAndReturn(run func() error) *MockIUserRepository_DeleteExpiredTokens_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteOldRevokedTokens provides a mock function with given fields: ctx, olderThan
func (_m *MockIUserRepository) DeleteOldRevokedTokens(ctx context.Context, olderThan time.Duration) error {
	ret := _m.Called(ctx, olderThan)

	if len(ret) == 0 {
		panic("no return value specified for DeleteOldRevokedTokens")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, time.Duration) error); ok {
		r0 = rf(ctx, olderThan)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockIUserRepository_DeleteOldRevokedTokens_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteOldRevokedTokens'
type MockIUserRepository_DeleteOldRevokedTokens_Call struct {
	*mock.Call
}

// DeleteOldRevokedTokens is a helper method to define mock.On call
//   - ctx context.Context
//   - olderThan time.Duration
func (_e *MockIUserRepository_Expecter) DeleteOldRevokedTokens(ctx interface{}, olderThan interface{}) *MockIUserRepository_DeleteOldRevokedTokens_Call {
	return &MockIUserRepository_DeleteOldRevokedTokens_Call{Call: _e.mock.On("DeleteOldRevokedTokens", ctx, olderThan)}
}

func (_c *MockIUserRepository_DeleteOldRevokedTokens_Call) Run(run func(ctx context.Context, olderThan time.Duration)) *MockIUserRepository_DeleteOldRevokedTokens_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(time.Duration))
	})
	return _c
}

func (_c *MockIUserRepository_DeleteOldRevokedTokens_Call) Return(_a0 error) *MockIUserRepository_DeleteOldRevokedTokens_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockIUserRepository_DeleteOldRevokedTokens_Call) RunAndReturn(run func(context.Context, time.Duration) error) *MockIUserRepository_DeleteOldRevokedTokens_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteUnverifiedExpiredUsers provides a mock function with given fields: ctx, expiration
func (_m *MockIUserRepository) DeleteUnverifiedExpiredUsers(ctx context.Context, expiration time.Duration) error {
	ret := _m.Called(ctx, expiration)

	if len(ret) == 0 {
		panic("no return value specified for DeleteUnverifiedExpiredUsers")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, time.Duration) error); ok {
		r0 = rf(ctx, expiration)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockIUserRepository_DeleteUnverifiedExpiredUsers_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteUnverifiedExpiredUsers'
type MockIUserRepository_DeleteUnverifiedExpiredUsers_Call struct {
	*mock.Call
}

// DeleteUnverifiedExpiredUsers is a helper method to define mock.On call
//   - ctx context.Context
//   - expiration time.Duration
func (_e *MockIUserRepository_Expecter) DeleteUnverifiedExpiredUsers(ctx interface{}, expiration interface{}) *MockIUserRepository_DeleteUnverifiedExpiredUsers_Call {
	return &MockIUserRepository_DeleteUnverifiedExpiredUsers_Call{Call: _e.mock.On("DeleteUnverifiedExpiredUsers", ctx, expiration)}
}

func (_c *MockIUserRepository_DeleteUnverifiedExpiredUsers_Call) Run(run func(ctx context.Context, expiration time.Duration)) *MockIUserRepository_DeleteUnverifiedExpiredUsers_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(time.Duration))
	})
	return _c
}

func (_c *MockIUserRepository_DeleteUnverifiedExpiredUsers_Call) Return(_a0 error) *MockIUserRepository_DeleteUnverifiedExpiredUsers_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockIUserRepository_DeleteUnverifiedExpiredUsers_Call) RunAndReturn(run func(context.Context, time.Duration) error) *MockIUserRepository_DeleteUnverifiedExpiredUsers_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteUser provides a mock function with given fields: ctx, id
func (_m *MockIUserRepository) DeleteUser(ctx context.Context, id string) error {
	ret := _m.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for DeleteUser")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, id)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockIUserRepository_DeleteUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteUser'
type MockIUserRepository_DeleteUser_Call struct {
	*mock.Call
}

// DeleteUser is a helper method to define mock.On call
//   - ctx context.Context
//   - id string
func (_e *MockIUserRepository_Expecter) DeleteUser(ctx interface{}, id interface{}) *MockIUserRepository_DeleteUser_Call {
	return &MockIUserRepository_DeleteUser_Call{Call: _e.mock.On("DeleteUser", ctx, id)}
}

func (_c *MockIUserRepository_DeleteUser_Call) Run(run func(ctx context.Context, id string)) *MockIUserRepository_DeleteUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockIUserRepository_DeleteUser_Call) Return(_a0 error) *MockIUserRepository_DeleteUser_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockIUserRepository_DeleteUser_Call) RunAndReturn(run func(context.Context, string) error) *MockIUserRepository_DeleteUser_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteVerificationToken provides a mock function with given fields: ctx, token
func (_m *MockIUserRepository) DeleteVerificationToken(ctx context.Context, token string) error {
	ret := _m.Called(ctx, token)

	if len(ret) == 0 {
		panic("no return value specified for DeleteVerificationToken")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, token)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockIUserRepository_DeleteVerificationToken_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteVerificationToken'
type MockIUserRepository_DeleteVerificationToken_Call struct {
	*mock.Call
}

// DeleteVerificationToken is a helper method to define mock.On call
//   - ctx context.Context
//   - token string
func (_e *MockIUserRepository_Expecter) DeleteVerificationToken(ctx interface{}, token interface{}) *MockIUserRepository_DeleteVerificationToken_Call {
	return &MockIUserRepository_DeleteVerificationToken_Call{Call: _e.mock.On("DeleteVerificationToken", ctx, token)}
}

func (_c *MockIUserRepository_DeleteVerificationToken_Call) Run(run func(ctx context.Context, token string)) *MockIUserRepository_DeleteVerificationToken_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockIUserRepository_DeleteVerificationToken_Call) Return(_a0 error) *MockIUserRepository_DeleteVerificationToken_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockIUserRepository_DeleteVerificationToken_Call) RunAndReturn(run func(context.Context, string) error) *MockIUserRepository_DeleteVerificationToken_Call {
	_c.Call.Return(run)
	return _c
}

// DemoteToUser provides a mock function with given fields: ctx, userID
func (_m *MockIUserRepository) DemoteToUser(ctx context.Context, userID string) error {
	ret := _m.Called(ctx, userID)

	if len(ret) == 0 {
		panic("no return value specified for DemoteToUser")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, userID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockIUserRepository_DemoteToUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DemoteToUser'
type MockIUserRepository_DemoteToUser_Call struct {
	*mock.Call
}

// DemoteToUser is a helper method to define mock.On call
//   - ctx context.Context
//   - userID string
func (_e *MockIUserRepository_Expecter) DemoteToUser(ctx interface{}, userID interface{}) *MockIUserRepository_DemoteToUser_Call {
	return &MockIUserRepository_DemoteToUser_Call{Call: _e.mock.On("DemoteToUser", ctx, userID)}
}

func (_c *MockIUserRepository_DemoteToUser_Call) Run(run func(ctx context.Context, userID string)) *MockIUserRepository_DemoteToUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockIUserRepository_DemoteToUser_Call) Return(_a0 error) *MockIUserRepository_DemoteToUser_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockIUserRepository_DemoteToUser_Call) RunAndReturn(run func(context.Context, string) error) *MockIUserRepository_DemoteToUser_Call {
	_c.Call.Return(run)
	return _c
}

// GetByEmail provides a mock function with given fields: ctx, email
func (_m *MockIUserRepository) GetByEmail(ctx context.Context, email string) (*domain.User, error) {
	ret := _m.Called(ctx, email)

	if len(ret) == 0 {
		panic("no return value specified for GetByEmail")
	}

	var r0 *domain.User
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*domain.User, error)); ok {
		return rf(ctx, email)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *domain.User); ok {
		r0 = rf(ctx, email)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*domain.User)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, email)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockIUserRepository_GetByEmail_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetByEmail'
type MockIUserRepository_GetByEmail_Call struct {
	*mock.Call
}

// GetByEmail is a helper method to define mock.On call
//   - ctx context.Context
//   - email string
func (_e *MockIUserRepository_Expecter) GetByEmail(ctx interface{}, email interface{}) *MockIUserRepository_GetByEmail_Call {
	return &MockIUserRepository_GetByEmail_Call{Call: _e.mock.On("GetByEmail", ctx, email)}
}

func (_c *MockIUserRepository_GetByEmail_Call) Run(run func(ctx context.Context, email string)) *MockIUserRepository_GetByEmail_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockIUserRepository_GetByEmail_Call) Return(_a0 *domain.User, _a1 error) *MockIUserRepository_GetByEmail_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockIUserRepository_GetByEmail_Call) RunAndReturn(run func(context.Context, string) (*domain.User, error)) *MockIUserRepository_GetByEmail_Call {
	_c.Call.Return(run)
	return _c
}

// GetByID provides a mock function with given fields: ctx, id
func (_m *MockIUserRepository) GetByID(ctx context.Context, id string) (*domain.User, error) {
	ret := _m.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for GetByID")
	}

	var r0 *domain.User
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*domain.User, error)); ok {
		return rf(ctx, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *domain.User); ok {
		r0 = rf(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*domain.User)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockIUserRepository_GetByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetByID'
type MockIUserRepository_GetByID_Call struct {
	*mock.Call
}

// GetByID is a helper method to define mock.On call
//   - ctx context.Context
//   - id string
func (_e *MockIUserRepository_Expecter) GetByID(ctx interface{}, id interface{}) *MockIUserRepository_GetByID_Call {
	return &MockIUserRepository_GetByID_Call{Call: _e.mock.On("GetByID", ctx, id)}
}

func (_c *MockIUserRepository_GetByID_Call) Run(run func(ctx context.Context, id string)) *MockIUserRepository_GetByID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockIUserRepository_GetByID_Call) Return(_a0 *domain.User, _a1 error) *MockIUserRepository_GetByID_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockIUserRepository_GetByID_Call) RunAndReturn(run func(context.Context, string) (*domain.User, error)) *MockIUserRepository_GetByID_Call {
	_c.Call.Return(run)
	return _c
}

// GetByToken provides a mock function with given fields: ctx, token
func (_m *MockIUserRepository) GetByToken(ctx context.Context, token string) (*domain.RefreshToken, error) {
	ret := _m.Called(ctx, token)

	if len(ret) == 0 {
		panic("no return value specified for GetByToken")
	}

	var r0 *domain.RefreshToken
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*domain.RefreshToken, error)); ok {
		return rf(ctx, token)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *domain.RefreshToken); ok {
		r0 = rf(ctx, token)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*domain.RefreshToken)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, token)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockIUserRepository_GetByToken_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetByToken'
type MockIUserRepository_GetByToken_Call struct {
	*mock.Call
}

// GetByToken is a helper method to define mock.On call
//   - ctx context.Context
//   - token string
func (_e *MockIUserRepository_Expecter) GetByToken(ctx interface{}, token interface{}) *MockIUserRepository_GetByToken_Call {
	return &MockIUserRepository_GetByToken_Call{Call: _e.mock.On("GetByToken", ctx, token)}
}

func (_c *MockIUserRepository_GetByToken_Call) Run(run func(ctx context.Context, token string)) *MockIUserRepository_GetByToken_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockIUserRepository_GetByToken_Call) Return(_a0 *domain.RefreshToken, _a1 error) *MockIUserRepository_GetByToken_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockIUserRepository_GetByToken_Call) RunAndReturn(run func(context.Context, string) (*domain.RefreshToken, error)) *MockIUserRepository_GetByToken_Call {
	_c.Call.Return(run)
	return _c
}

// GetByUsername provides a mock function with given fields: ctx, username
func (_m *MockIUserRepository) GetByUsername(ctx context.Context, username string) (*domain.User, error) {
	ret := _m.Called(ctx, username)

	if len(ret) == 0 {
		panic("no return value specified for GetByUsername")
	}

	var r0 *domain.User
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*domain.User, error)); ok {
		return rf(ctx, username)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *domain.User); ok {
		r0 = rf(ctx, username)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*domain.User)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, username)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockIUserRepository_GetByUsername_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetByUsername'
type MockIUserRepository_GetByUsername_Call struct {
	*mock.Call
}

// GetByUsername is a helper method to define mock.On call
//   - ctx context.Context
//   - username string
func (_e *MockIUserRepository_Expecter) GetByUsername(ctx interface{}, username interface{}) *MockIUserRepository_GetByUsername_Call {
	return &MockIUserRepository_GetByUsername_Call{Call: _e.mock.On("GetByUsername", ctx, username)}
}

func (_c *MockIUserRepository_GetByUsername_Call) Run(run func(ctx context.Context, username string)) *MockIUserRepository_GetByUsername_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockIUserRepository_GetByUsername_Call) Return(_a0 *domain.User, _a1 error) *MockIUserRepository_GetByUsername_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockIUserRepository_GetByUsername_Call) RunAndReturn(run func(context.Context, string) (*domain.User, error)) *MockIUserRepository_GetByUsername_Call {
	_c.Call.Return(run)
	return _c
}

// GetValidByUser provides a mock function with given fields: ctx, userID
func (_m *MockIUserRepository) GetValidByUser(ctx context.Context, userID string) ([]*domain.RefreshToken, error) {
	ret := _m.Called(ctx, userID)

	if len(ret) == 0 {
		panic("no return value specified for GetValidByUser")
	}

	var r0 []*domain.RefreshToken
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) ([]*domain.RefreshToken, error)); ok {
		return rf(ctx, userID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) []*domain.RefreshToken); ok {
		r0 = rf(ctx, userID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*domain.RefreshToken)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, userID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockIUserRepository_GetValidByUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetValidByUser'
type MockIUserRepository_GetValidByUser_Call struct {
	*mock.Call
}

// GetValidByUser is a helper method to define mock.On call
//   - ctx context.Context
//   - userID string
func (_e *MockIUserRepository_Expecter) GetValidByUser(ctx interface{}, userID interface{}) *MockIUserRepository_GetValidByUser_Call {
	return &MockIUserRepository_GetValidByUser_Call{Call: _e.mock.On("GetValidByUser", ctx, userID)}
}

func (_c *MockIUserRepository_GetValidByUser_Call) Run(run func(ctx context.Context, userID string)) *MockIUserRepository_GetValidByUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockIUserRepository_GetValidByUser_Call) Return(_a0 []*domain.RefreshToken, _a1 error) *MockIUserRepository_GetValidByUser_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockIUserRepository_GetValidByUser_Call) RunAndReturn(run func(context.Context, string) ([]*domain.RefreshToken, error)) *MockIUserRepository_GetValidByUser_Call {
	_c.Call.Return(run)
	return _c
}

// GetVerificationToken provides a mock function with given fields: ctx, emailToken
func (_m *MockIUserRepository) GetVerificationToken(ctx context.Context, emailToken string) (*domain.EmailVerificationToken, error) {
	ret := _m.Called(ctx, emailToken)

	if len(ret) == 0 {
		panic("no return value specified for GetVerificationToken")
	}

	var r0 *domain.EmailVerificationToken
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*domain.EmailVerificationToken, error)); ok {
		return rf(ctx, emailToken)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *domain.EmailVerificationToken); ok {
		r0 = rf(ctx, emailToken)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*domain.EmailVerificationToken)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, emailToken)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockIUserRepository_GetVerificationToken_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetVerificationToken'
type MockIUserRepository_GetVerificationToken_Call struct {
	*mock.Call
}

// GetVerificationToken is a helper method to define mock.On call
//   - ctx context.Context
//   - emailToken string
func (_e *MockIUserRepository_Expecter) GetVerificationToken(ctx interface{}, emailToken interface{}) *MockIUserRepository_GetVerificationToken_Call {
	return &MockIUserRepository_GetVerificationToken_Call{Call: _e.mock.On("GetVerificationToken", ctx, emailToken)}
}

func (_c *MockIUserRepository_GetVerificationToken_Call) Run(run func(ctx context.Context, emailToken string)) *MockIUserRepository_GetVerificationToken_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockIUserRepository_GetVerificationToken_Call) Return(_a0 *domain.EmailVerificationToken, _a1 error) *MockIUserRepository_GetVerificationToken_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockIUserRepository_GetVerificationToken_Call) RunAndReturn(run func(context.Context, string) (*domain.EmailVerificationToken, error)) *MockIUserRepository_GetVerificationToken_Call {
	_c.Call.Return(run)
	return _c
}

// PromoteToAdmin provides a mock function with given fields: ctx, userID
func (_m *MockIUserRepository) PromoteToAdmin(ctx context.Context, userID string) error {
	ret := _m.Called(ctx, userID)

	if len(ret) == 0 {
		panic("no return value specified for PromoteToAdmin")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, userID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockIUserRepository_PromoteToAdmin_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PromoteToAdmin'
type MockIUserRepository_PromoteToAdmin_Call struct {
	*mock.Call
}

// PromoteToAdmin is a helper method to define mock.On call
//   - ctx context.Context
//   - userID string
func (_e *MockIUserRepository_Expecter) PromoteToAdmin(ctx interface{}, userID interface{}) *MockIUserRepository_PromoteToAdmin_Call {
	return &MockIUserRepository_PromoteToAdmin_Call{Call: _e.mock.On("PromoteToAdmin", ctx, userID)}
}

func (_c *MockIUserRepository_PromoteToAdmin_Call) Run(run func(ctx context.Context, userID string)) *MockIUserRepository_PromoteToAdmin_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockIUserRepository_PromoteToAdmin_Call) Return(_a0 error) *MockIUserRepository_PromoteToAdmin_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockIUserRepository_PromoteToAdmin_Call) RunAndReturn(run func(context.Context, string) error) *MockIUserRepository_PromoteToAdmin_Call {
	_c.Call.Return(run)
	return _c
}

// RevokeAllByUser provides a mock function with given fields: ctx, userID
func (_m *MockIUserRepository) RevokeAllByUser(ctx context.Context, userID string) error {
	ret := _m.Called(ctx, userID)

	if len(ret) == 0 {
		panic("no return value specified for RevokeAllByUser")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, userID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockIUserRepository_RevokeAllByUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RevokeAllByUser'
type MockIUserRepository_RevokeAllByUser_Call struct {
	*mock.Call
}

// RevokeAllByUser is a helper method to define mock.On call
//   - ctx context.Context
//   - userID string
func (_e *MockIUserRepository_Expecter) RevokeAllByUser(ctx interface{}, userID interface{}) *MockIUserRepository_RevokeAllByUser_Call {
	return &MockIUserRepository_RevokeAllByUser_Call{Call: _e.mock.On("RevokeAllByUser", ctx, userID)}
}

func (_c *MockIUserRepository_RevokeAllByUser_Call) Run(run func(ctx context.Context, userID string)) *MockIUserRepository_RevokeAllByUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockIUserRepository_RevokeAllByUser_Call) Return(_a0 error) *MockIUserRepository_RevokeAllByUser_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockIUserRepository_RevokeAllByUser_Call) RunAndReturn(run func(context.Context, string) error) *MockIUserRepository_RevokeAllByUser_Call {
	_c.Call.Return(run)
	return _c
}

// RevokeToken provides a mock function with given fields: ctx, token
func (_m *MockIUserRepository) RevokeToken(ctx context.Context, token string) error {
	ret := _m.Called(ctx, token)

	if len(ret) == 0 {
		panic("no return value specified for RevokeToken")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, token)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockIUserRepository_RevokeToken_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RevokeToken'
type MockIUserRepository_RevokeToken_Call struct {
	*mock.Call
}

// RevokeToken is a helper method to define mock.On call
//   - ctx context.Context
//   - token string
func (_e *MockIUserRepository_Expecter) RevokeToken(ctx interface{}, token interface{}) *MockIUserRepository_RevokeToken_Call {
	return &MockIUserRepository_RevokeToken_Call{Call: _e.mock.On("RevokeToken", ctx, token)}
}

func (_c *MockIUserRepository_RevokeToken_Call) Run(run func(ctx context.Context, token string)) *MockIUserRepository_RevokeToken_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockIUserRepository_RevokeToken_Call) Return(_a0 error) *MockIUserRepository_RevokeToken_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockIUserRepository_RevokeToken_Call) RunAndReturn(run func(context.Context, string) error) *MockIUserRepository_RevokeToken_Call {
	_c.Call.Return(run)
	return _c
}

// SaveVerificationToken provides a mock function with given fields: ctx, emailToken
func (_m *MockIUserRepository) SaveVerificationToken(ctx context.Context, emailToken *domain.EmailVerificationToken) error {
	ret := _m.Called(ctx, emailToken)

	if len(ret) == 0 {
		panic("no return value specified for SaveVerificationToken")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *domain.EmailVerificationToken) error); ok {
		r0 = rf(ctx, emailToken)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockIUserRepository_SaveVerificationToken_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SaveVerificationToken'
type MockIUserRepository_SaveVerificationToken_Call struct {
	*mock.Call
}

// SaveVerificationToken is a helper method to define mock.On call
//   - ctx context.Context
//   - emailToken *domain.EmailVerificationToken
func (_e *MockIUserRepository_Expecter) SaveVerificationToken(ctx interface{}, emailToken interface{}) *MockIUserRepository_SaveVerificationToken_Call {
	return &MockIUserRepository_SaveVerificationToken_Call{Call: _e.mock.On("SaveVerificationToken", ctx, emailToken)}
}

func (_c *MockIUserRepository_SaveVerificationToken_Call) Run(run func(ctx context.Context, emailToken *domain.EmailVerificationToken)) *MockIUserRepository_SaveVerificationToken_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*domain.EmailVerificationToken))
	})
	return _c
}

func (_c *MockIUserRepository_SaveVerificationToken_Call) Return(_a0 error) *MockIUserRepository_SaveVerificationToken_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockIUserRepository_SaveVerificationToken_Call) RunAndReturn(run func(context.Context, *domain.EmailVerificationToken) error) *MockIUserRepository_SaveVerificationToken_Call {
	_c.Call.Return(run)
	return _c
}

// StoreToken provides a mock function with given fields: ctx, token
func (_m *MockIUserRepository) StoreToken(ctx context.Context, token *domain.RefreshToken) error {
	ret := _m.Called(ctx, token)

	if len(ret) == 0 {
		panic("no return value specified for StoreToken")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *domain.RefreshToken) error); ok {
		r0 = rf(ctx, token)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockIUserRepository_StoreToken_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StoreToken'
type MockIUserRepository_StoreToken_Call struct {
	*mock.Call
}

// StoreToken is a helper method to define mock.On call
//   - ctx context.Context
//   - token *domain.RefreshToken
func (_e *MockIUserRepository_Expecter) StoreToken(ctx interface{}, token interface{}) *MockIUserRepository_StoreToken_Call {
	return &MockIUserRepository_StoreToken_Call{Call: _e.mock.On("StoreToken", ctx, token)}
}

func (_c *MockIUserRepository_StoreToken_Call) Run(run func(ctx context.Context, token *domain.RefreshToken)) *MockIUserRepository_StoreToken_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*domain.RefreshToken))
	})
	return _c
}

func (_c *MockIUserRepository_StoreToken_Call) Return(_a0 error) *MockIUserRepository_StoreToken_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockIUserRepository_StoreToken_Call) RunAndReturn(run func(context.Context, *domain.RefreshToken) error) *MockIUserRepository_StoreToken_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateUser provides a mock function with given fields: ctx, user
func (_m *MockIUserRepository) UpdateUser(ctx context.Context, user *domain.User) error {
	ret := _m.Called(ctx, user)

	if len(ret) == 0 {
		panic("no return value specified for UpdateUser")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *domain.User) error); ok {
		r0 = rf(ctx, user)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockIUserRepository_UpdateUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateUser'
type MockIUserRepository_UpdateUser_Call struct {
	*mock.Call
}

// UpdateUser is a helper method to define mock.On call
//   - ctx context.Context
//   - user *domain.User
func (_e *MockIUserRepository_Expecter) UpdateUser(ctx interface{}, user interface{}) *MockIUserRepository_UpdateUser_Call {
	return &MockIUserRepository_UpdateUser_Call{Call: _e.mock.On("UpdateUser", ctx, user)}
}

func (_c *MockIUserRepository_UpdateUser_Call) Run(run func(ctx context.Context, user *domain.User)) *MockIUserRepository_UpdateUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*domain.User))
	})
	return _c
}

func (_c *MockIUserRepository_UpdateUser_Call) Return(_a0 error) *MockIUserRepository_UpdateUser_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockIUserRepository_UpdateUser_Call) RunAndReturn(run func(context.Context, *domain.User) error) *MockIUserRepository_UpdateUser_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockIUserRepository creates a new instance of MockIUserRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockIUserRepository(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockIUserRepository {
	mock := &MockIUserRepository{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
