// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package mocks

import (
	"context"
	"time"
	"write_base/internal/domain"

	mock "github.com/stretchr/testify/mock"
)

// NewMockIArticleRepository creates a new instance of MockIArticleRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockIArticleRepository(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockIArticleRepository {
	mock := &MockIArticleRepository{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockIArticleRepository is an autogenerated mock type for the IArticleRepository type
type MockIArticleRepository struct {
	mock.Mock
}

type MockIArticleRepository_Expecter struct {
	mock *mock.Mock
}

func (_m *MockIArticleRepository) EXPECT() *MockIArticleRepository_Expecter {
	return &MockIArticleRepository_Expecter{mock: &_m.Mock}
}

// AdminListAllArticles provides a mock function for the type MockIArticleRepository
func (_mock *MockIArticleRepository) AdminListAllArticles(ctx context.Context, pag domain.Pagination) ([]domain.Article, int, error) {
	ret := _mock.Called(ctx, pag)

	if len(ret) == 0 {
		panic("no return value specified for AdminListAllArticles")
	}

	var r0 []domain.Article
	var r1 int
	var r2 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, domain.Pagination) ([]domain.Article, int, error)); ok {
		return returnFunc(ctx, pag)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, domain.Pagination) []domain.Article); ok {
		r0 = returnFunc(ctx, pag)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]domain.Article)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, domain.Pagination) int); ok {
		r1 = returnFunc(ctx, pag)
	} else {
		r1 = ret.Get(1).(int)
	}
	if returnFunc, ok := ret.Get(2).(func(context.Context, domain.Pagination) error); ok {
		r2 = returnFunc(ctx, pag)
	} else {
		r2 = ret.Error(2)
	}
	return r0, r1, r2
}

// MockIArticleRepository_AdminListAllArticles_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AdminListAllArticles'
type MockIArticleRepository_AdminListAllArticles_Call struct {
	*mock.Call
}

// AdminListAllArticles is a helper method to define mock.On call
//   - ctx context.Context
//   - pag domain.Pagination
func (_e *MockIArticleRepository_Expecter) AdminListAllArticles(ctx interface{}, pag interface{}) *MockIArticleRepository_AdminListAllArticles_Call {
	return &MockIArticleRepository_AdminListAllArticles_Call{Call: _e.mock.On("AdminListAllArticles", ctx, pag)}
}

func (_c *MockIArticleRepository_AdminListAllArticles_Call) Run(run func(ctx context.Context, pag domain.Pagination)) *MockIArticleRepository_AdminListAllArticles_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 domain.Pagination
		if args[1] != nil {
			arg1 = args[1].(domain.Pagination)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockIArticleRepository_AdminListAllArticles_Call) Return(articles []domain.Article, n int, err error) *MockIArticleRepository_AdminListAllArticles_Call {
	_c.Call.Return(articles, n, err)
	return _c
}

func (_c *MockIArticleRepository_AdminListAllArticles_Call) RunAndReturn(run func(ctx context.Context, pag domain.Pagination) ([]domain.Article, int, error)) *MockIArticleRepository_AdminListAllArticles_Call {
	_c.Call.Return(run)
	return _c
}

// Archive provides a mock function for the type MockIArticleRepository
func (_mock *MockIArticleRepository) Archive(ctx context.Context, articleID string, archiveAt time.Time) error {
	ret := _mock.Called(ctx, articleID, archiveAt)

	if len(ret) == 0 {
		panic("no return value specified for Archive")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, time.Time) error); ok {
		r0 = returnFunc(ctx, articleID, archiveAt)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockIArticleRepository_Archive_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Archive'
type MockIArticleRepository_Archive_Call struct {
	*mock.Call
}

// Archive is a helper method to define mock.On call
//   - ctx context.Context
//   - articleID string
//   - archiveAt time.Time
func (_e *MockIArticleRepository_Expecter) Archive(ctx interface{}, articleID interface{}, archiveAt interface{}) *MockIArticleRepository_Archive_Call {
	return &MockIArticleRepository_Archive_Call{Call: _e.mock.On("Archive", ctx, articleID, archiveAt)}
}

func (_c *MockIArticleRepository_Archive_Call) Run(run func(ctx context.Context, articleID string, archiveAt time.Time)) *MockIArticleRepository_Archive_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 time.Time
		if args[2] != nil {
			arg2 = args[2].(time.Time)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockIArticleRepository_Archive_Call) Return(err error) *MockIArticleRepository_Archive_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockIArticleRepository_Archive_Call) RunAndReturn(run func(ctx context.Context, articleID string, archiveAt time.Time) error) *MockIArticleRepository_Archive_Call {
	_c.Call.Return(run)
	return _c
}

// Delete provides a mock function for the type MockIArticleRepository
func (_mock *MockIArticleRepository) Delete(ctx context.Context, articleID string) error {
	ret := _mock.Called(ctx, articleID)

	if len(ret) == 0 {
		panic("no return value specified for Delete")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = returnFunc(ctx, articleID)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockIArticleRepository_Delete_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Delete'
type MockIArticleRepository_Delete_Call struct {
	*mock.Call
}

// Delete is a helper method to define mock.On call
//   - ctx context.Context
//   - articleID string
func (_e *MockIArticleRepository_Expecter) Delete(ctx interface{}, articleID interface{}) *MockIArticleRepository_Delete_Call {
	return &MockIArticleRepository_Delete_Call{Call: _e.mock.On("Delete", ctx, articleID)}
}

func (_c *MockIArticleRepository_Delete_Call) Run(run func(ctx context.Context, articleID string)) *MockIArticleRepository_Delete_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockIArticleRepository_Delete_Call) Return(err error) *MockIArticleRepository_Delete_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockIArticleRepository_Delete_Call) RunAndReturn(run func(ctx context.Context, articleID string) error) *MockIArticleRepository_Delete_Call {
	_c.Call.Return(run)
	return _c
}

// EmptyTrash provides a mock function for the type MockIArticleRepository
func (_mock *MockIArticleRepository) EmptyTrash(ctx context.Context, userID string) error {
	ret := _mock.Called(ctx, userID)

	if len(ret) == 0 {
		panic("no return value specified for EmptyTrash")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = returnFunc(ctx, userID)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockIArticleRepository_EmptyTrash_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EmptyTrash'
type MockIArticleRepository_EmptyTrash_Call struct {
	*mock.Call
}

// EmptyTrash is a helper method to define mock.On call
//   - ctx context.Context
//   - userID string
func (_e *MockIArticleRepository_Expecter) EmptyTrash(ctx interface{}, userID interface{}) *MockIArticleRepository_EmptyTrash_Call {
	return &MockIArticleRepository_EmptyTrash_Call{Call: _e.mock.On("EmptyTrash", ctx, userID)}
}

func (_c *MockIArticleRepository_EmptyTrash_Call) Run(run func(ctx context.Context, userID string)) *MockIArticleRepository_EmptyTrash_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockIArticleRepository_EmptyTrash_Call) Return(err error) *MockIArticleRepository_EmptyTrash_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockIArticleRepository_EmptyTrash_Call) RunAndReturn(run func(ctx context.Context, userID string) error) *MockIArticleRepository_EmptyTrash_Call {
	_c.Call.Return(run)
	return _c
}

// Filter provides a mock function for the type MockIArticleRepository
func (_mock *MockIArticleRepository) Filter(ctx context.Context, filter domain.ArticleFilter, pag domain.Pagination) ([]domain.Article, int, error) {
	ret := _mock.Called(ctx, filter, pag)

	if len(ret) == 0 {
		panic("no return value specified for Filter")
	}

	var r0 []domain.Article
	var r1 int
	var r2 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, domain.ArticleFilter, domain.Pagination) ([]domain.Article, int, error)); ok {
		return returnFunc(ctx, filter, pag)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, domain.ArticleFilter, domain.Pagination) []domain.Article); ok {
		r0 = returnFunc(ctx, filter, pag)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]domain.Article)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, domain.ArticleFilter, domain.Pagination) int); ok {
		r1 = returnFunc(ctx, filter, pag)
	} else {
		r1 = ret.Get(1).(int)
	}
	if returnFunc, ok := ret.Get(2).(func(context.Context, domain.ArticleFilter, domain.Pagination) error); ok {
		r2 = returnFunc(ctx, filter, pag)
	} else {
		r2 = ret.Error(2)
	}
	return r0, r1, r2
}

// MockIArticleRepository_Filter_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Filter'
type MockIArticleRepository_Filter_Call struct {
	*mock.Call
}

// Filter is a helper method to define mock.On call
//   - ctx context.Context
//   - filter domain.ArticleFilter
//   - pag domain.Pagination
func (_e *MockIArticleRepository_Expecter) Filter(ctx interface{}, filter interface{}, pag interface{}) *MockIArticleRepository_Filter_Call {
	return &MockIArticleRepository_Filter_Call{Call: _e.mock.On("Filter", ctx, filter, pag)}
}

func (_c *MockIArticleRepository_Filter_Call) Run(run func(ctx context.Context, filter domain.ArticleFilter, pag domain.Pagination)) *MockIArticleRepository_Filter_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 domain.ArticleFilter
		if args[1] != nil {
			arg1 = args[1].(domain.ArticleFilter)
		}
		var arg2 domain.Pagination
		if args[2] != nil {
			arg2 = args[2].(domain.Pagination)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockIArticleRepository_Filter_Call) Return(articles []domain.Article, n int, err error) *MockIArticleRepository_Filter_Call {
	_c.Call.Return(articles, n, err)
	return _c
}

func (_c *MockIArticleRepository_Filter_Call) RunAndReturn(run func(ctx context.Context, filter domain.ArticleFilter, pag domain.Pagination) ([]domain.Article, int, error)) *MockIArticleRepository_Filter_Call {
	_c.Call.Return(run)
	return _c
}

// FilterAuthorArticles provides a mock function for the type MockIArticleRepository
func (_mock *MockIArticleRepository) FilterAuthorArticles(ctx context.Context, authorID string, filter domain.ArticleFilter, pag domain.Pagination) ([]domain.Article, int, error) {
	ret := _mock.Called(ctx, authorID, filter, pag)

	if len(ret) == 0 {
		panic("no return value specified for FilterAuthorArticles")
	}

	var r0 []domain.Article
	var r1 int
	var r2 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, domain.ArticleFilter, domain.Pagination) ([]domain.Article, int, error)); ok {
		return returnFunc(ctx, authorID, filter, pag)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, domain.ArticleFilter, domain.Pagination) []domain.Article); ok {
		r0 = returnFunc(ctx, authorID, filter, pag)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]domain.Article)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, domain.ArticleFilter, domain.Pagination) int); ok {
		r1 = returnFunc(ctx, authorID, filter, pag)
	} else {
		r1 = ret.Get(1).(int)
	}
	if returnFunc, ok := ret.Get(2).(func(context.Context, string, domain.ArticleFilter, domain.Pagination) error); ok {
		r2 = returnFunc(ctx, authorID, filter, pag)
	} else {
		r2 = ret.Error(2)
	}
	return r0, r1, r2
}

// MockIArticleRepository_FilterAuthorArticles_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FilterAuthorArticles'
type MockIArticleRepository_FilterAuthorArticles_Call struct {
	*mock.Call
}

// FilterAuthorArticles is a helper method to define mock.On call
//   - ctx context.Context
//   - authorID string
//   - filter domain.ArticleFilter
//   - pag domain.Pagination
func (_e *MockIArticleRepository_Expecter) FilterAuthorArticles(ctx interface{}, authorID interface{}, filter interface{}, pag interface{}) *MockIArticleRepository_FilterAuthorArticles_Call {
	return &MockIArticleRepository_FilterAuthorArticles_Call{Call: _e.mock.On("FilterAuthorArticles", ctx, authorID, filter, pag)}
}

func (_c *MockIArticleRepository_FilterAuthorArticles_Call) Run(run func(ctx context.Context, authorID string, filter domain.ArticleFilter, pag domain.Pagination)) *MockIArticleRepository_FilterAuthorArticles_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 domain.ArticleFilter
		if args[2] != nil {
			arg2 = args[2].(domain.ArticleFilter)
		}
		var arg3 domain.Pagination
		if args[3] != nil {
			arg3 = args[3].(domain.Pagination)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
		)
	})
	return _c
}

func (_c *MockIArticleRepository_FilterAuthorArticles_Call) Return(articles []domain.Article, n int, err error) *MockIArticleRepository_FilterAuthorArticles_Call {
	_c.Call.Return(articles, n, err)
	return _c
}

func (_c *MockIArticleRepository_FilterAuthorArticles_Call) RunAndReturn(run func(ctx context.Context, authorID string, filter domain.ArticleFilter, pag domain.Pagination) ([]domain.Article, int, error)) *MockIArticleRepository_FilterAuthorArticles_Call {
	_c.Call.Return(run)
	return _c
}

// GetByID provides a mock function for the type MockIArticleRepository
func (_mock *MockIArticleRepository) GetByID(ctx context.Context, articleID string) (*domain.Article, error) {
	ret := _mock.Called(ctx, articleID)

	if len(ret) == 0 {
		panic("no return value specified for GetByID")
	}

	var r0 *domain.Article
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (*domain.Article, error)); ok {
		return returnFunc(ctx, articleID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) *domain.Article); ok {
		r0 = returnFunc(ctx, articleID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*domain.Article)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, articleID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockIArticleRepository_GetByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetByID'
type MockIArticleRepository_GetByID_Call struct {
	*mock.Call
}

// GetByID is a helper method to define mock.On call
//   - ctx context.Context
//   - articleID string
func (_e *MockIArticleRepository_Expecter) GetByID(ctx interface{}, articleID interface{}) *MockIArticleRepository_GetByID_Call {
	return &MockIArticleRepository_GetByID_Call{Call: _e.mock.On("GetByID", ctx, articleID)}
}

func (_c *MockIArticleRepository_GetByID_Call) Run(run func(ctx context.Context, articleID string)) *MockIArticleRepository_GetByID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockIArticleRepository_GetByID_Call) Return(article *domain.Article, err error) *MockIArticleRepository_GetByID_Call {
	_c.Call.Return(article, err)
	return _c
}

func (_c *MockIArticleRepository_GetByID_Call) RunAndReturn(run func(ctx context.Context, articleID string) (*domain.Article, error)) *MockIArticleRepository_GetByID_Call {
	_c.Call.Return(run)
	return _c
}

// GetBySlug provides a mock function for the type MockIArticleRepository
func (_mock *MockIArticleRepository) GetBySlug(ctx context.Context, slug string) (*domain.Article, error) {
	ret := _mock.Called(ctx, slug)

	if len(ret) == 0 {
		panic("no return value specified for GetBySlug")
	}

	var r0 *domain.Article
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (*domain.Article, error)); ok {
		return returnFunc(ctx, slug)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) *domain.Article); ok {
		r0 = returnFunc(ctx, slug)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*domain.Article)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, slug)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockIArticleRepository_GetBySlug_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetBySlug'
type MockIArticleRepository_GetBySlug_Call struct {
	*mock.Call
}

// GetBySlug is a helper method to define mock.On call
//   - ctx context.Context
//   - slug string
func (_e *MockIArticleRepository_Expecter) GetBySlug(ctx interface{}, slug interface{}) *MockIArticleRepository_GetBySlug_Call {
	return &MockIArticleRepository_GetBySlug_Call{Call: _e.mock.On("GetBySlug", ctx, slug)}
}

func (_c *MockIArticleRepository_GetBySlug_Call) Run(run func(ctx context.Context, slug string)) *MockIArticleRepository_GetBySlug_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockIArticleRepository_GetBySlug_Call) Return(article *domain.Article, err error) *MockIArticleRepository_GetBySlug_Call {
	_c.Call.Return(article, err)
	return _c
}

func (_c *MockIArticleRepository_GetBySlug_Call) RunAndReturn(run func(ctx context.Context, slug string) (*domain.Article, error)) *MockIArticleRepository_GetBySlug_Call {
	_c.Call.Return(run)
	return _c
}

// HardDelete provides a mock function for the type MockIArticleRepository
func (_mock *MockIArticleRepository) HardDelete(ctx context.Context, articleID string) error {
	ret := _mock.Called(ctx, articleID)

	if len(ret) == 0 {
		panic("no return value specified for HardDelete")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = returnFunc(ctx, articleID)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockIArticleRepository_HardDelete_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HardDelete'
type MockIArticleRepository_HardDelete_Call struct {
	*mock.Call
}

// HardDelete is a helper method to define mock.On call
//   - ctx context.Context
//   - articleID string
func (_e *MockIArticleRepository_Expecter) HardDelete(ctx interface{}, articleID interface{}) *MockIArticleRepository_HardDelete_Call {
	return &MockIArticleRepository_HardDelete_Call{Call: _e.mock.On("HardDelete", ctx, articleID)}
}

func (_c *MockIArticleRepository_HardDelete_Call) Run(run func(ctx context.Context, articleID string)) *MockIArticleRepository_HardDelete_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockIArticleRepository_HardDelete_Call) Return(err error) *MockIArticleRepository_HardDelete_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockIArticleRepository_HardDelete_Call) RunAndReturn(run func(ctx context.Context, articleID string) error) *MockIArticleRepository_HardDelete_Call {
	_c.Call.Return(run)
	return _c
}

// IncrementClap provides a mock function for the type MockIArticleRepository
func (_mock *MockIArticleRepository) IncrementClap(ctx context.Context, articleID string) error {
	ret := _mock.Called(ctx, articleID)

	if len(ret) == 0 {
		panic("no return value specified for IncrementClap")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = returnFunc(ctx, articleID)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockIArticleRepository_IncrementClap_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IncrementClap'
type MockIArticleRepository_IncrementClap_Call struct {
	*mock.Call
}

// IncrementClap is a helper method to define mock.On call
//   - ctx context.Context
//   - articleID string
func (_e *MockIArticleRepository_Expecter) IncrementClap(ctx interface{}, articleID interface{}) *MockIArticleRepository_IncrementClap_Call {
	return &MockIArticleRepository_IncrementClap_Call{Call: _e.mock.On("IncrementClap", ctx, articleID)}
}

func (_c *MockIArticleRepository_IncrementClap_Call) Run(run func(ctx context.Context, articleID string)) *MockIArticleRepository_IncrementClap_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockIArticleRepository_IncrementClap_Call) Return(err error) *MockIArticleRepository_IncrementClap_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockIArticleRepository_IncrementClap_Call) RunAndReturn(run func(ctx context.Context, articleID string) error) *MockIArticleRepository_IncrementClap_Call {
	_c.Call.Return(run)
	return _c
}

// IncrementView provides a mock function for the type MockIArticleRepository
func (_mock *MockIArticleRepository) IncrementView(ctx context.Context, articleID string) error {
	ret := _mock.Called(ctx, articleID)

	if len(ret) == 0 {
		panic("no return value specified for IncrementView")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = returnFunc(ctx, articleID)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockIArticleRepository_IncrementView_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IncrementView'
type MockIArticleRepository_IncrementView_Call struct {
	*mock.Call
}

// IncrementView is a helper method to define mock.On call
//   - ctx context.Context
//   - articleID string
func (_e *MockIArticleRepository_Expecter) IncrementView(ctx interface{}, articleID interface{}) *MockIArticleRepository_IncrementView_Call {
	return &MockIArticleRepository_IncrementView_Call{Call: _e.mock.On("IncrementView", ctx, articleID)}
}

func (_c *MockIArticleRepository_IncrementView_Call) Run(run func(ctx context.Context, articleID string)) *MockIArticleRepository_IncrementView_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockIArticleRepository_IncrementView_Call) Return(err error) *MockIArticleRepository_IncrementView_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockIArticleRepository_IncrementView_Call) RunAndReturn(run func(ctx context.Context, articleID string) error) *MockIArticleRepository_IncrementView_Call {
	_c.Call.Return(run)
	return _c
}

// Insert provides a mock function for the type MockIArticleRepository
func (_mock *MockIArticleRepository) Insert(ctx context.Context, article *domain.Article) (*domain.Article, error) {
	ret := _mock.Called(ctx, article)

	if len(ret) == 0 {
		panic("no return value specified for Insert")
	}

	var r0 *domain.Article
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *domain.Article) (*domain.Article, error)); ok {
		return returnFunc(ctx, article)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *domain.Article) *domain.Article); ok {
		r0 = returnFunc(ctx, article)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*domain.Article)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *domain.Article) error); ok {
		r1 = returnFunc(ctx, article)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockIArticleRepository_Insert_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Insert'
type MockIArticleRepository_Insert_Call struct {
	*mock.Call
}

// Insert is a helper method to define mock.On call
//   - ctx context.Context
//   - article *domain.Article
func (_e *MockIArticleRepository_Expecter) Insert(ctx interface{}, article interface{}) *MockIArticleRepository_Insert_Call {
	return &MockIArticleRepository_Insert_Call{Call: _e.mock.On("Insert", ctx, article)}
}

func (_c *MockIArticleRepository_Insert_Call) Run(run func(ctx context.Context, article *domain.Article)) *MockIArticleRepository_Insert_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *domain.Article
		if args[1] != nil {
			arg1 = args[1].(*domain.Article)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockIArticleRepository_Insert_Call) Return(article1 *domain.Article, err error) *MockIArticleRepository_Insert_Call {
	_c.Call.Return(article1, err)
	return _c
}

func (_c *MockIArticleRepository_Insert_Call) RunAndReturn(run func(ctx context.Context, article *domain.Article) (*domain.Article, error)) *MockIArticleRepository_Insert_Call {
	_c.Call.Return(run)
	return _c
}

// ListAuthorArticles provides a mock function for the type MockIArticleRepository
func (_mock *MockIArticleRepository) ListAuthorArticles(ctx context.Context, authorID string, pag domain.Pagination) ([]domain.Article, int, error) {
	ret := _mock.Called(ctx, authorID, pag)

	if len(ret) == 0 {
		panic("no return value specified for ListAuthorArticles")
	}

	var r0 []domain.Article
	var r1 int
	var r2 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, domain.Pagination) ([]domain.Article, int, error)); ok {
		return returnFunc(ctx, authorID, pag)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, domain.Pagination) []domain.Article); ok {
		r0 = returnFunc(ctx, authorID, pag)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]domain.Article)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, domain.Pagination) int); ok {
		r1 = returnFunc(ctx, authorID, pag)
	} else {
		r1 = ret.Get(1).(int)
	}
	if returnFunc, ok := ret.Get(2).(func(context.Context, string, domain.Pagination) error); ok {
		r2 = returnFunc(ctx, authorID, pag)
	} else {
		r2 = ret.Error(2)
	}
	return r0, r1, r2
}

// MockIArticleRepository_ListAuthorArticles_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListAuthorArticles'
type MockIArticleRepository_ListAuthorArticles_Call struct {
	*mock.Call
}

// ListAuthorArticles is a helper method to define mock.On call
//   - ctx context.Context
//   - authorID string
//   - pag domain.Pagination
func (_e *MockIArticleRepository_Expecter) ListAuthorArticles(ctx interface{}, authorID interface{}, pag interface{}) *MockIArticleRepository_ListAuthorArticles_Call {
	return &MockIArticleRepository_ListAuthorArticles_Call{Call: _e.mock.On("ListAuthorArticles", ctx, authorID, pag)}
}

func (_c *MockIArticleRepository_ListAuthorArticles_Call) Run(run func(ctx context.Context, authorID string, pag domain.Pagination)) *MockIArticleRepository_ListAuthorArticles_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 domain.Pagination
		if args[2] != nil {
			arg2 = args[2].(domain.Pagination)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockIArticleRepository_ListAuthorArticles_Call) Return(articles []domain.Article, n int, err error) *MockIArticleRepository_ListAuthorArticles_Call {
	_c.Call.Return(articles, n, err)
	return _c
}

func (_c *MockIArticleRepository_ListAuthorArticles_Call) RunAndReturn(run func(ctx context.Context, authorID string, pag domain.Pagination) ([]domain.Article, int, error)) *MockIArticleRepository_ListAuthorArticles_Call {
	_c.Call.Return(run)
	return _c
}

// ListByAuthor provides a mock function for the type MockIArticleRepository
func (_mock *MockIArticleRepository) ListByAuthor(ctx context.Context, authorID string, pag domain.Pagination) ([]domain.Article, int, error) {
	ret := _mock.Called(ctx, authorID, pag)

	if len(ret) == 0 {
		panic("no return value specified for ListByAuthor")
	}

	var r0 []domain.Article
	var r1 int
	var r2 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, domain.Pagination) ([]domain.Article, int, error)); ok {
		return returnFunc(ctx, authorID, pag)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, domain.Pagination) []domain.Article); ok {
		r0 = returnFunc(ctx, authorID, pag)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]domain.Article)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, domain.Pagination) int); ok {
		r1 = returnFunc(ctx, authorID, pag)
	} else {
		r1 = ret.Get(1).(int)
	}
	if returnFunc, ok := ret.Get(2).(func(context.Context, string, domain.Pagination) error); ok {
		r2 = returnFunc(ctx, authorID, pag)
	} else {
		r2 = ret.Error(2)
	}
	return r0, r1, r2
}

// MockIArticleRepository_ListByAuthor_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListByAuthor'
type MockIArticleRepository_ListByAuthor_Call struct {
	*mock.Call
}

// ListByAuthor is a helper method to define mock.On call
//   - ctx context.Context
//   - authorID string
//   - pag domain.Pagination
func (_e *MockIArticleRepository_Expecter) ListByAuthor(ctx interface{}, authorID interface{}, pag interface{}) *MockIArticleRepository_ListByAuthor_Call {
	return &MockIArticleRepository_ListByAuthor_Call{Call: _e.mock.On("ListByAuthor", ctx, authorID, pag)}
}

func (_c *MockIArticleRepository_ListByAuthor_Call) Run(run func(ctx context.Context, authorID string, pag domain.Pagination)) *MockIArticleRepository_ListByAuthor_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 domain.Pagination
		if args[2] != nil {
			arg2 = args[2].(domain.Pagination)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockIArticleRepository_ListByAuthor_Call) Return(articles []domain.Article, n int, err error) *MockIArticleRepository_ListByAuthor_Call {
	_c.Call.Return(articles, n, err)
	return _c
}

func (_c *MockIArticleRepository_ListByAuthor_Call) RunAndReturn(run func(ctx context.Context, authorID string, pag domain.Pagination) ([]domain.Article, int, error)) *MockIArticleRepository_ListByAuthor_Call {
	_c.Call.Return(run)
	return _c
}

// ListByTag provides a mock function for the type MockIArticleRepository
func (_mock *MockIArticleRepository) ListByTag(ctx context.Context, tag string, pag domain.Pagination) ([]domain.Article, int, error) {
	ret := _mock.Called(ctx, tag, pag)

	if len(ret) == 0 {
		panic("no return value specified for ListByTag")
	}

	var r0 []domain.Article
	var r1 int
	var r2 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, domain.Pagination) ([]domain.Article, int, error)); ok {
		return returnFunc(ctx, tag, pag)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, domain.Pagination) []domain.Article); ok {
		r0 = returnFunc(ctx, tag, pag)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]domain.Article)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, domain.Pagination) int); ok {
		r1 = returnFunc(ctx, tag, pag)
	} else {
		r1 = ret.Get(1).(int)
	}
	if returnFunc, ok := ret.Get(2).(func(context.Context, string, domain.Pagination) error); ok {
		r2 = returnFunc(ctx, tag, pag)
	} else {
		r2 = ret.Error(2)
	}
	return r0, r1, r2
}

// MockIArticleRepository_ListByTag_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListByTag'
type MockIArticleRepository_ListByTag_Call struct {
	*mock.Call
}

// ListByTag is a helper method to define mock.On call
//   - ctx context.Context
//   - tag string
//   - pag domain.Pagination
func (_e *MockIArticleRepository_Expecter) ListByTag(ctx interface{}, tag interface{}, pag interface{}) *MockIArticleRepository_ListByTag_Call {
	return &MockIArticleRepository_ListByTag_Call{Call: _e.mock.On("ListByTag", ctx, tag, pag)}
}

func (_c *MockIArticleRepository_ListByTag_Call) Run(run func(ctx context.Context, tag string, pag domain.Pagination)) *MockIArticleRepository_ListByTag_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 domain.Pagination
		if args[2] != nil {
			arg2 = args[2].(domain.Pagination)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockIArticleRepository_ListByTag_Call) Return(articles []domain.Article, n int, err error) *MockIArticleRepository_ListByTag_Call {
	_c.Call.Return(articles, n, err)
	return _c
}

func (_c *MockIArticleRepository_ListByTag_Call) RunAndReturn(run func(ctx context.Context, tag string, pag domain.Pagination) ([]domain.Article, int, error)) *MockIArticleRepository_ListByTag_Call {
	_c.Call.Return(run)
	return _c
}

// ListTrending provides a mock function for the type MockIArticleRepository
func (_mock *MockIArticleRepository) ListTrending(ctx context.Context, pag domain.Pagination, windowDays int) ([]domain.Article, int, error) {
	ret := _mock.Called(ctx, pag, windowDays)

	if len(ret) == 0 {
		panic("no return value specified for ListTrending")
	}

	var r0 []domain.Article
	var r1 int
	var r2 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, domain.Pagination, int) ([]domain.Article, int, error)); ok {
		return returnFunc(ctx, pag, windowDays)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, domain.Pagination, int) []domain.Article); ok {
		r0 = returnFunc(ctx, pag, windowDays)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]domain.Article)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, domain.Pagination, int) int); ok {
		r1 = returnFunc(ctx, pag, windowDays)
	} else {
		r1 = ret.Get(1).(int)
	}
	if returnFunc, ok := ret.Get(2).(func(context.Context, domain.Pagination, int) error); ok {
		r2 = returnFunc(ctx, pag, windowDays)
	} else {
		r2 = ret.Error(2)
	}
	return r0, r1, r2
}

// MockIArticleRepository_ListTrending_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListTrending'
type MockIArticleRepository_ListTrending_Call struct {
	*mock.Call
}

// ListTrending is a helper method to define mock.On call
//   - ctx context.Context
//   - pag domain.Pagination
//   - windowDays int
func (_e *MockIArticleRepository_Expecter) ListTrending(ctx interface{}, pag interface{}, windowDays interface{}) *MockIArticleRepository_ListTrending_Call {
	return &MockIArticleRepository_ListTrending_Call{Call: _e.mock.On("ListTrending", ctx, pag, windowDays)}
}

func (_c *MockIArticleRepository_ListTrending_Call) Run(run func(ctx context.Context, pag domain.Pagination, windowDays int)) *MockIArticleRepository_ListTrending_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 domain.Pagination
		if args[1] != nil {
			arg1 = args[1].(domain.Pagination)
		}
		var arg2 int
		if args[2] != nil {
			arg2 = args[2].(int)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockIArticleRepository_ListTrending_Call) Return(articles []domain.Article, n int, err error) *MockIArticleRepository_ListTrending_Call {
	_c.Call.Return(articles, n, err)
	return _c
}

func (_c *MockIArticleRepository_ListTrending_Call) RunAndReturn(run func(ctx context.Context, pag domain.Pagination, windowDays int) ([]domain.Article, int, error)) *MockIArticleRepository_ListTrending_Call {
	_c.Call.Return(run)
	return _c
}

// Publish provides a mock function for the type MockIArticleRepository
func (_mock *MockIArticleRepository) Publish(ctx context.Context, articleID string, publishAt time.Time) error {
	ret := _mock.Called(ctx, articleID, publishAt)

	if len(ret) == 0 {
		panic("no return value specified for Publish")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, time.Time) error); ok {
		r0 = returnFunc(ctx, articleID, publishAt)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockIArticleRepository_Publish_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Publish'
type MockIArticleRepository_Publish_Call struct {
	*mock.Call
}

// Publish is a helper method to define mock.On call
//   - ctx context.Context
//   - articleID string
//   - publishAt time.Time
func (_e *MockIArticleRepository_Expecter) Publish(ctx interface{}, articleID interface{}, publishAt interface{}) *MockIArticleRepository_Publish_Call {
	return &MockIArticleRepository_Publish_Call{Call: _e.mock.On("Publish", ctx, articleID, publishAt)}
}

func (_c *MockIArticleRepository_Publish_Call) Run(run func(ctx context.Context, articleID string, publishAt time.Time)) *MockIArticleRepository_Publish_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 time.Time
		if args[2] != nil {
			arg2 = args[2].(time.Time)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockIArticleRepository_Publish_Call) Return(err error) *MockIArticleRepository_Publish_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockIArticleRepository_Publish_Call) RunAndReturn(run func(ctx context.Context, articleID string, publishAt time.Time) error) *MockIArticleRepository_Publish_Call {
	_c.Call.Return(run)
	return _c
}

// Restore provides a mock function for the type MockIArticleRepository
func (_mock *MockIArticleRepository) Restore(ctx context.Context, articleID string) (*domain.Article, error) {
	ret := _mock.Called(ctx, articleID)

	if len(ret) == 0 {
		panic("no return value specified for Restore")
	}

	var r0 *domain.Article
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) (*domain.Article, error)); ok {
		return returnFunc(ctx, articleID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) *domain.Article); ok {
		r0 = returnFunc(ctx, articleID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*domain.Article)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = returnFunc(ctx, articleID)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockIArticleRepository_Restore_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Restore'
type MockIArticleRepository_Restore_Call struct {
	*mock.Call
}

// Restore is a helper method to define mock.On call
//   - ctx context.Context
//   - articleID string
func (_e *MockIArticleRepository_Expecter) Restore(ctx interface{}, articleID interface{}) *MockIArticleRepository_Restore_Call {
	return &MockIArticleRepository_Restore_Call{Call: _e.mock.On("Restore", ctx, articleID)}
}

func (_c *MockIArticleRepository_Restore_Call) Run(run func(ctx context.Context, articleID string)) *MockIArticleRepository_Restore_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockIArticleRepository_Restore_Call) Return(article *domain.Article, err error) *MockIArticleRepository_Restore_Call {
	_c.Call.Return(article, err)
	return _c
}

func (_c *MockIArticleRepository_Restore_Call) RunAndReturn(run func(ctx context.Context, articleID string) (*domain.Article, error)) *MockIArticleRepository_Restore_Call {
	_c.Call.Return(run)
	return _c
}

// Search provides a mock function for the type MockIArticleRepository
func (_mock *MockIArticleRepository) Search(ctx context.Context, query string, pag domain.Pagination) ([]domain.Article, int, error) {
	ret := _mock.Called(ctx, query, pag)

	if len(ret) == 0 {
		panic("no return value specified for Search")
	}

	var r0 []domain.Article
	var r1 int
	var r2 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, domain.Pagination) ([]domain.Article, int, error)); ok {
		return returnFunc(ctx, query, pag)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, domain.Pagination) []domain.Article); ok {
		r0 = returnFunc(ctx, query, pag)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]domain.Article)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, domain.Pagination) int); ok {
		r1 = returnFunc(ctx, query, pag)
	} else {
		r1 = ret.Get(1).(int)
	}
	if returnFunc, ok := ret.Get(2).(func(context.Context, string, domain.Pagination) error); ok {
		r2 = returnFunc(ctx, query, pag)
	} else {
		r2 = ret.Error(2)
	}
	return r0, r1, r2
}

// MockIArticleRepository_Search_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Search'
type MockIArticleRepository_Search_Call struct {
	*mock.Call
}

// Search is a helper method to define mock.On call
//   - ctx context.Context
//   - query string
//   - pag domain.Pagination
func (_e *MockIArticleRepository_Expecter) Search(ctx interface{}, query interface{}, pag interface{}) *MockIArticleRepository_Search_Call {
	return &MockIArticleRepository_Search_Call{Call: _e.mock.On("Search", ctx, query, pag)}
}

func (_c *MockIArticleRepository_Search_Call) Run(run func(ctx context.Context, query string, pag domain.Pagination)) *MockIArticleRepository_Search_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 domain.Pagination
		if args[2] != nil {
			arg2 = args[2].(domain.Pagination)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockIArticleRepository_Search_Call) Return(articles []domain.Article, n int, err error) *MockIArticleRepository_Search_Call {
	_c.Call.Return(articles, n, err)
	return _c
}

func (_c *MockIArticleRepository_Search_Call) RunAndReturn(run func(ctx context.Context, query string, pag domain.Pagination) ([]domain.Article, int, error)) *MockIArticleRepository_Search_Call {
	_c.Call.Return(run)
	return _c
}

// Unarchive provides a mock function for the type MockIArticleRepository
func (_mock *MockIArticleRepository) Unarchive(ctx context.Context, articleID string) error {
	ret := _mock.Called(ctx, articleID)

	if len(ret) == 0 {
		panic("no return value specified for Unarchive")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = returnFunc(ctx, articleID)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockIArticleRepository_Unarchive_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Unarchive'
type MockIArticleRepository_Unarchive_Call struct {
	*mock.Call
}

// Unarchive is a helper method to define mock.On call
//   - ctx context.Context
//   - articleID string
func (_e *MockIArticleRepository_Expecter) Unarchive(ctx interface{}, articleID interface{}) *MockIArticleRepository_Unarchive_Call {
	return &MockIArticleRepository_Unarchive_Call{Call: _e.mock.On("Unarchive", ctx, articleID)}
}

func (_c *MockIArticleRepository_Unarchive_Call) Run(run func(ctx context.Context, articleID string)) *MockIArticleRepository_Unarchive_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockIArticleRepository_Unarchive_Call) Return(err error) *MockIArticleRepository_Unarchive_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockIArticleRepository_Unarchive_Call) RunAndReturn(run func(ctx context.Context, articleID string) error) *MockIArticleRepository_Unarchive_Call {
	_c.Call.Return(run)
	return _c
}

// Unpublish provides a mock function for the type MockIArticleRepository
func (_mock *MockIArticleRepository) Unpublish(ctx context.Context, articleID string) error {
	ret := _mock.Called(ctx, articleID)

	if len(ret) == 0 {
		panic("no return value specified for Unpublish")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = returnFunc(ctx, articleID)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockIArticleRepository_Unpublish_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Unpublish'
type MockIArticleRepository_Unpublish_Call struct {
	*mock.Call
}

// Unpublish is a helper method to define mock.On call
//   - ctx context.Context
//   - articleID string
func (_e *MockIArticleRepository_Expecter) Unpublish(ctx interface{}, articleID interface{}) *MockIArticleRepository_Unpublish_Call {
	return &MockIArticleRepository_Unpublish_Call{Call: _e.mock.On("Unpublish", ctx, articleID)}
}

func (_c *MockIArticleRepository_Unpublish_Call) Run(run func(ctx context.Context, articleID string)) *MockIArticleRepository_Unpublish_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockIArticleRepository_Unpublish_Call) Return(err error) *MockIArticleRepository_Unpublish_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockIArticleRepository_Unpublish_Call) RunAndReturn(run func(ctx context.Context, articleID string) error) *MockIArticleRepository_Unpublish_Call {
	_c.Call.Return(run)
	return _c
}

// Update provides a mock function for the type MockIArticleRepository
func (_mock *MockIArticleRepository) Update(ctx context.Context, article *domain.Article) (*domain.Article, error) {
	ret := _mock.Called(ctx, article)

	if len(ret) == 0 {
		panic("no return value specified for Update")
	}

	var r0 *domain.Article
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *domain.Article) (*domain.Article, error)); ok {
		return returnFunc(ctx, article)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *domain.Article) *domain.Article); ok {
		r0 = returnFunc(ctx, article)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*domain.Article)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *domain.Article) error); ok {
		r1 = returnFunc(ctx, article)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockIArticleRepository_Update_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Update'
type MockIArticleRepository_Update_Call struct {
	*mock.Call
}

// Update is a helper method to define mock.On call
//   - ctx context.Context
//   - article *domain.Article
func (_e *MockIArticleRepository_Expecter) Update(ctx interface{}, article interface{}) *MockIArticleRepository_Update_Call {
	return &MockIArticleRepository_Update_Call{Call: _e.mock.On("Update", ctx, article)}
}

func (_c *MockIArticleRepository_Update_Call) Run(run func(ctx context.Context, article *domain.Article)) *MockIArticleRepository_Update_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *domain.Article
		if args[1] != nil {
			arg1 = args[1].(*domain.Article)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockIArticleRepository_Update_Call) Return(article1 *domain.Article, err error) *MockIArticleRepository_Update_Call {
	_c.Call.Return(article1, err)
	return _c
}

func (_c *MockIArticleRepository_Update_Call) RunAndReturn(run func(ctx context.Context, article *domain.Article) (*domain.Article, error)) *MockIArticleRepository_Update_Call {
	_c.Call.Return(run)
	return _c
}
